# -*- coding: utf-8 -*-
"""BHMMPractice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fsKeHZiDwlHa2R3UE_Kxn89hGgWUPDUj
"""

!pip install backtrader

# Install dependencie
!pip install tensorflow-probability tensorflow
!pip install sklearn
# Import libraries
import numpy as np
import pandas as pd
import yfinance as yf
import datetime as dt
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
import tensorflow as tf
import tensorflow_probability as tfp

def dataMiner(symbols, chunks=10, save_csv=False):
    all_data = []

    for symbol in symbols:
        end_date = dt.datetime.today()
        df_list = []

        for _ in range(chunks):
            df = yf.Ticker(symbol).history(start=end_date - pd.Timedelta(days=60), end=end_date, interval="2m")

            if df.empty:
                break

            df_list.append(df)
            end_date = df.index.min()

        if df_list:
            df_combined = pd.concat(df_list).drop_duplicates().sort_index()
            df_combined["Symbol"] = symbol
            all_data.append(df_combined)

    if all_data:
        final_df = pd.concat(all_data)
        if save_csv:
            final_df.to_csv("multi_asset_1h_data.csv")
        return final_df
    return None

df = dataMiner(["BTC-USD"], chunks=50, save_csv=True)

df["log_return"] = np.log(df["Close"] / df["Close"].shift(1))
df["volatility"] = df["log_return"].rolling(30).std()
df["momentum"] = df["Close"].diff(5)
df["ewma_20"] = df["Close"].ewm(span=20).mean()
df["vwap"] = (df["Close"] * df["Volume"]).cumsum() / df["Volume"].cumsum()
df["price_vs_vwap"] = df["Close"] - df["vwap"]
df["price_vs_ewma"] = df["Close"] - df["ewma_20"]

features = ["log_return", "volatility", "momentum", "price_vs_vwap", "price_vs_ewma"]
df.dropna(inplace=True)
scaler = StandardScaler()
df[features] = scaler.fit_transform(df[features])

observations = tf.convert_to_tensor(df[features].values,dtype=tf.float32)
tfd = tfp.distributions

n_states = 3
n_obs, n_features = observations.shape

model = tfd.HiddenMarkovModel(
    initial_distribution=tfd.Categorical(probs=[1.0/n_states]*n_states),
    transition_distribution=tfd.Categorical(probs=[
        [0.7, 0.2, 0.1],
        [0.3, 0.5, 0.2],
        [0.2, 0.3, 0.5]
    ]),
    observation_distribution=tfd.MultivariateNormalDiag(
        loc=tf.Variable(tf.random.normal([n_states, n_features])),
        scale_diag=tf.Variable(tf.ones([n_states, n_features]))
    ),
    num_steps=n_obs
)

# 6) Infer hidden states
predicted_states = model.posterior_mode(observations)
df["bhmm_regime"] = predicted_states.numpy()

# 7) Create regime statistics
regime_stats = df.groupby("bhmm_regime")["log_return"].agg(["mean", "std"])
print(regime_stats)

# 8) Label states with custom logic
#    "Bearish" -> negative mean, highest std among negative-mean states
#    "Bullish" -> positive mean, highest std among positive-mean states
#    "Sideways" -> leftover
def label_regimes(stats):
    # Identify negative-mean states
    neg_states = stats[stats["mean"] < 0]
    if not neg_states.empty:
        # Pick the negative-mean state with the highest std
        bearish_idx = neg_states["std"].idxmax()
    else:
        # Fallback if none are negative
        bearish_idx = stats["mean"].idxmin()

    # Identify positive-mean states
    pos_states = stats[stats["mean"] > 0]
    if not pos_states.empty:
        # Pick the positive-mean state with the highest std
        bullish_idx = pos_states["std"].idxmax()
    else:
        # Fallback if none are positive
        bullish_idx = stats["mean"].idxmax()

    # The remaining state becomes sideways
    leftover = [i for i in stats.index if i not in [bearish_idx, bullish_idx]]
    sideways_idx = leftover[0] if leftover else None

    return {
        bearish_idx:  "Bearish",
        bullish_idx:  "Bullish",
        sideways_idx: "Sideways" if sideways_idx is not None else None
    }

regime_mapping = label_regimes(regime_stats)
df["market_phase"] = df["bhmm_regime"].map(regime_mapping)

# Commented out IPython magic to ensure Python compatibility.
# Ensure Matplotlib renders properly in Google Colab
import matplotlib.pyplot as plt
from IPython.display import display
import numpy as np
import pandas as pd

# Ensure plots display properly in Google Colab
# %matplotlib inline
plt.ion()

# Define colors dictionary
colors = {
    "Bullish": "green",
    "Bearish": "red",
    "Sideways": "blue"
}

# Define date range
start_date = "2025-02-23"
end_date   = "2025-02-26"

# Ensure df has a DateTime index
df.index = pd.to_datetime(df.index)

# Filter the DataFrame based on the date range
df_sub = df.loc[start_date:end_date].copy()

# Check if df_sub is empty
if df_sub.empty:
    print("⚠️ No data available in the given date range! Adjust start_date and end_date.")
else:
    print(f"✅ df_sub contains {df_sub.shape[0]} rows.")

# Ensure "bhmm_regime" column exists
if "bhmm_regime" not in df_sub.columns:
    raise KeyError("❌ 'bhmm_regime' column is missing from df_sub!")

# Function to calculate mode for rolling window
def mode_of_window(x):
    x = x.astype(int)
    vals, cnts = np.unique(x, return_counts=True)
    max_count = cnts.max()
    candidates = vals[cnts == max_count]
    center_val = int(x[len(x)//2])
    if center_val in candidates:
        return center_val
    else:
        differences = np.abs(candidates - center_val)
        return candidates[differences.argmin()]

# Apply rolling mode function
df_sub["market_phase_smoothed_numeric"] = (
    df_sub["bhmm_regime"]
    .rolling(window=30, center=True, min_periods=1)
    .apply(mode_of_window, raw=True)
)

# Ensure regime_mapping is defined
if "regime_mapping" not in globals():
    raise KeyError("❌ 'regime_mapping' dictionary is missing!")

# Map numeric market phase values to labels
df_sub["market_phase_smoothed"] = df_sub["market_phase_smoothed_numeric"].map(regime_mapping)

# Fill NaN values if mapping fails
df_sub["market_phase_smoothed"].fillna("Unknown", inplace=True)

# Ensure 'market_phase' exists and doesn't have NaNs
df_sub["market_phase"].fillna("Unknown", inplace=True)

# Check unique market phases to ensure they exist in colors dictionary
unique_phases = df_sub["market_phase"].unique()
unique_smoothed_phases = df_sub["market_phase_smoothed"].unique()
print(f"Market phases found: {unique_phases}")
print(f"Smoothed market phases found: {unique_smoothed_phases}")

# Safe plotting function
def safe_color(phase):
    return colors.get(phase, "black")  # Default to black if phase is missing

# ✅ Plot original market phases
plt.figure(figsize=(15, 6))
for phase in unique_phases:
    mask = df_sub["market_phase"] == phase
    plt.plot(df_sub.index[mask], df_sub["Close"][mask], ".", label=phase, color=safe_color(phase))
plt.title("Original Market Phases")
plt.xlabel("Date")
plt.ylabel("Close Price")
plt.legend()
display(plt.gcf())  # Ensure Google Colab displays the figure

# ✅ Plot smoothed market phases
plt.figure(figsize=(15, 6))
for phase in unique_smoothed_phases:
    mask = df_sub["market_phase_smoothed"] == phase
    plt.plot(df_sub.index[mask], df_sub["Close"][mask], ".", label=phase, color=safe_color(phase))
plt.title("Smoothed Market Phases (Rolling Mode over 30 Points)")
plt.xlabel("Date")
plt.ylabel("Close Price")
plt.legend()
display(plt.gcf())  # Ensure Google Colab displays the figure

import backtrader as bt
import matplotlib.pyplot as plt
import pandas as pd

# Map the market_phase string to numeric values
phase_numeric_mapping = {"Bearish": -1, "Sideways": 0, "Bullish": 1}
df["phase_num"] = df_sub["market_phase_smoothed"].map(phase_numeric_mapping)

# Create a custom Pandas data feed that includes the extra column "phase_num"
class CustomPandasData(bt.feeds.PandasData):
    lines = ('phase_num',)
    params = (('phase_num', -1),)

# Define the Backtrader Strategy
class RegimeStrategy(bt.Strategy):
    params = (('ma_period', 50),)

    def __init__(self):
        self.ma = bt.indicators.SimpleMovingAverage(self.data.close, period=self.p.ma_period)

    def next(self):
        phase = self.data.phase_num[0]
        if phase == 1:  # Bullish: go long
            if self.position.size <= 0:
                if self.position:
                    self.close()
                self.buy()
        elif phase == -1:  # Bearish: short
            if self.position.size >= 0:
                if self.position:
                    self.close()
                self.sell()
        elif phase == 0:  # Sideways: mean reversion rule
            if self.data.close[0] > self.ma[0]:
                if self.position.size >= 0:
                    if self.position:
                        self.close()
                    self.sell()
            elif self.data.close[0] < self.ma[0]:
                if self.position.size <= 0:
                    if self.position:
                        self.close()
                    self.buy()

# Set up Cerebro and add your existing df via the custom data feed
cerebro = bt.Cerebro()
data = CustomPandasData(dataname=df)
cerebro.adddata(data)
cerebro.addstrategy(RegimeStrategy, ma_period=50)

# Set starting cash and commission (e.g., 0.1% per trade)
cerebro.broker.setcash(100000)
cerebro.broker.setcommission(commission=0.00)

# Add a TimeReturn analyzer to compute returns at each time step
cerebro.addanalyzer(bt.analyzers.TimeReturn, _name='timeReturn')

print("Starting Portfolio Value: %.2f" % cerebro.broker.getvalue())
results = cerebro.run()
first_strategy = results[0]
print("Final Portfolio Value: %.2f" % cerebro.broker.getvalue())

# Get the time-based returns from the analyzer
time_returns = first_strategy.analyzers.timeReturn.get_analysis()
# Convert to Pandas Series
returns_series = pd.Series(time_returns)
# Compute cumulative returns
cumulative_returns = (1 + returns_series).cumprod()

plt.figure(figsize=(15, 6))
plt.plot(cumulative_returns.index, cumulative_returns.values, label="Cumulative Return", color="blue")
plt.title("Strategy Cumulative Returns")
plt.xlabel("Date")
plt.ylabel("Cumulative Return")
plt.legend()
plt.show()

# Optional: Plot the Backtrader chart
cerebro.plot(style='candlestick')